class Renderer {
  constructor(size) {
    this.size = size;
    // generated by https://colordesigner.io/color-mixer
    this.bgcolors = {
      2: "#eee4da",
      4: "#eee1c9",
      // 8: "#eeddb8",
      8: "#f78e48",
      // 16: "#eedaa6",
      16: "#f69664",
      // 32: "#eed695",
      32: "#f77c5f",
      // 64: "#eed384",
      64: "#f75f3b",
      128: "#edd073",
      256: "#edcc62",
      512: "#edc950",
      1024: "#edc53f",
      2048: "#edc22e",
    };
    // text color for value > 4
    this.brightTextColor = "#f9f6f2";
    this.setup();
  }

  // setup grid
  setup() {
    this.gridContainer = document.querySelector(".grid-container");
    this.scoreContainer = document.querySelector(".score-text");
    // remove all children
    this.removeAllChildren(this.gridContainer);
    // add cells
    for (let i = 0; i < this.size * this.size; i++) {
      let cell = document.createElement("div");
      cell.classList.add("grid-cell");
      this.gridContainer.appendChild(cell);
    }
  }

  removeAllChildren(node) {
    // TODO: performence consuming?
    node.textContent = "";
  }

  getIndex(pos) {
    return pos.x * this.size + pos.y;
  }

  getPos(index) {
    return {
      x: index / this.size,
      y: index % this.size,
    };
  }

  clearCell(x, y) {
    let index = this.getIndex({ x: x, y: y });
    let cell = this.gridContainer.childNodes[index];
    this.removeAllChildren(cell);
  }

  // add tile to grid
  addTile(tile) {
    let index = this.getIndex({ x: tile.x, y: tile.y });
    // let cell = this.gridContainer.childNodes[index];
    let cell = this.gridContainer.children[index];
    this.removeAllChildren(cell);

    let tileNode = document.createElement("div");
    tileNode.classList.add("tile");
    // adjust text and color
    tileNode.textContent = tile.value;
    // TODO: bgcolors above 2048
    if (tile.value in this.bgcolors) {
      tileNode.style.backgroundColor = this.bgcolors[tile.value];
    }
    if (tile.value > 4) {
      tileNode.style.color = this.brightTextColor;
    }
    if (tile.value > 100) {
      tileNode.style.fontSize = "50px";
    } else if (tile.value > 1000) {
      tileNode.style.fontSize = "38px";
    }

    // animations
    if (tile.newborn) {
      tileNode.classList.add("tile-new");
    }

    if (tile.mergedFrom) {
      tileNode.classList.add("tile-merged");
    }

    cell.appendChild(tileNode);
  }

  render(grid, meta) {
    let self = this;
    grid.forEachCell((x, y, tile) => {
      if (tile) {
        self.addTile(tile);
      } else {
        self.clearCell(x, y);
      }
    });

    if (!meta) {
      meta = {
        score: 0,
      };
    }

    this.scoreContainer.textContent = meta.score;
  }
}
