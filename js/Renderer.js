class Renderer {
  constructor(size) {
    this.size = size;
    // generated by https://colordesigner.io/color-mixer
    this.bgcolors = {
      2: "#eee4da",
      4: "#eee1c9",
      // 8: "#eeddb8",
      8: "#f78e48",
      // 16: "#eedaa6",
      16: "#f69664",
      // 32: "#eed695",
      32: "#f77c5f",
      // 64: "#eed384",
      64: "#f75f3b",
      128: "#edd073",
      256: "#edcc62",
      512: "#edc950",
      1024: "#edc53f",
      2048: "#edc22e",
    };
    // text color for value > 4
    this.brightTextColor = "#f9f6f2";

    // DOM
    this.gridContainer = document.querySelector(".grid-container");
    this.scoreContainer = document.querySelector(".score-text");
    this.tipsContainer = document.querySelector(".tips-container");
    this.tipsWin = document.querySelector(".tips-win");
    this.tipsLose = document.querySelector(".tips-lose");

    this.setup();
  }

  // setup grid
  setup() {
    // remove all children
    this.removeAllChildren(this.gridContainer);
    // add cells
    for (let i = 0; i < this.size * this.size; i++) {
      let cell = document.createElement("div");
      cell.classList.add("grid-cell");
      this.gridContainer.appendChild(cell);
    }
  }

  removeAllChildren(node) {
    // TODO: performence consuming?
    node.textContent = "";
  }

  getIndex(pos) {
    return pos.x * this.size + pos.y;
  }

  getPos(index) {
    return {
      x: index / this.size,
      y: index % this.size,
    };
  }

  getCell(tile) {
    let index = this.getIndex({ x: tile.x, y: tile.y });
    let cell = this.gridContainer.childNodes[index];
    return cell;
  }

  clearCell(x, y) {
    let index = this.getIndex({ x: x, y: y });
    let cell = this.gridContainer.childNodes[index];
    this.removeAllChildren(cell);
  }

  distance(tile1, tile2) {
    let cell1 = this.getCell(tile1);
    let cell2 = this.getCell(tile2);
    let rect1 = cell1.getBoundingClientRect();
    let rect2 = cell2.getBoundingClientRect();
    return {
      x: rect2.x - rect1.x,
      y: rect2.y - rect1.y,
    };
  }

  createTile(tile) {
    let tileNode = document.createElement("div");
    tileNode.classList.add("tile");

    // adjust text and color
    tileNode.textContent = tile.value;
    // TODO: bgcolors above 2048
    if (tile.value in this.bgcolors) {
      tileNode.style.backgroundColor = this.bgcolors[tile.value];
    }
    if (tile.value > 4) {
      tileNode.style.color = this.brightTextColor;
    }
    if (tile.value > 100) {
      tileNode.classList.add("tile-100");
    } else if (tile.value > 1000) {
      tileNode.classList.add("tile-1000");
    }
    return tileNode;
  }

  addMovedTile(fromTile, toTile) {
    let node = this.addTile(fromTile);
    node.classList.add("tile-moved");
    // calculate offset
    let dis = this.distance(fromTile, toTile);
    node.style.transform = `translate(${dis.x}px, ${dis.y}px)`;
    return node;
  }

  // add tile to grid
  addTile(tile) {
    let self = this;
    let cell = this.getCell(tile);
    let tileNode = this.createTile(tile);

    // animations
    if (tile.newborn) {
      tileNode.classList.add("tile-new");
    }

    if (tile.mergedFrom) {
      tileNode.classList.add("tile-merged");
      // BUG: cannot render merged tile
      // tile.mergedFrom.forEach(function (origin) {
      //   self.addMovedTile(origin, tile);
      // });
    }

    if (tile.movedFrom) {
      this.addMovedTile(tile.movedFrom, tile);
      return;
    }

    cell.appendChild(tileNode);
    return tileNode;
  }

  render(grid, meta) {
    let self = this;
    grid.forEachCell((x, y, tile) => {
      self.clearCell(x, y);
    });
    grid.forEachCell((x, y, tile) => {
      if (tile) {
        self.addTile(tile);
      }
    });

    if (!meta) {
      meta = {
        score: 0,
        gameover: false,
        win: false,
      };
    }

    // update score
    this.scoreContainer.textContent = meta.score;

    // gameover or win
    if (meta.gameover) {
      this.tipsContainer.style.visibility = "visible";
      this.tipsLose.style.visibility = "visible";
    }
    if (meta.win) {
      this.tipsContainer.style.visibility = "visible";
      this.tipsWin.style.visibility = "visible";
    }
  }

  hideTips() {
    this.tipsContainer.style.visibility = "hidden";
    this.tipsWin.style.visibility = "hidden";
    this.tipsLose.style.visibility = "hidden";
  }
}
